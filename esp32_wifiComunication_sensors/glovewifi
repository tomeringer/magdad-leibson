#include <Wire.h>
#include <ICM_20948.h>
#include <WiFi.h>
#include <WiFiUdp.h>

// ========================================================
//                      WIFI SETUP
// ========================================================
const char* ssid = "YP";
const char* password = "ptyair101";
const char* computerIP = "192.168.104.164";
const int udpPort = 4210;

WiFiUDP udp;

// ========================================================
//                  PACKET FRAMING
// ========================================================
constexpr uint8_t START_BYTE = 0xAA;
constexpr uint8_t END_BYTE   = 0x55;

// ========================================================
//                       IMU SETUP
// ========================================================
ICM_20948_I2C imu;
#define AD0_VAL 0

constexpr float ACC_MG_TO_G = 0.001f;
constexpr float ALPHA_RP  = 0.98f;
constexpr float ALPHA_YAW = 0.98f;
constexpr float MAX_DT = 0.1f;

constexpr float ROLL_TH  = 45.0f;
constexpr float PITCH_TH = 30.0f;

constexpr float GYRO_BIAS_DPS_X = -0.8248f;
constexpr float GYRO_BIAS_DPS_Y =  0.1288f;
constexpr float GYRO_BIAS_DPS_Z = -0.5285f;

constexpr float MAG_OFF_X = 0.0f;
constexpr float MAG_OFF_Y = -46.7f;
constexpr float MAG_OFF_Z = -25.2f;

constexpr float MAG_SCALE_X = 0.984f;
constexpr float MAG_SCALE_Y = 1.05f;
constexpr float MAG_SCALE_Z = 1.0f;

// ========================================================
//                     FLEX SENSOR SETUP
// ========================================================
constexpr int NUM_FLEX = 4;
int flexPins[NUM_FLEX] = {A0, A1, A2, A3};

float R_FIXED[NUM_FLEX]  = {47000, 47000, 47000, 47000};
float R_THRESH[NUM_FLEX] = {40000, 22000, 32000, 22000};
constexpr float V_IN = 3.3;

float flexR[NUM_FLEX];

// ========================================================
//                       DATA TYPES
// ========================================================
struct Vec3 { float x, y, z; };
struct Orientation { float roll, pitch, yaw; };

// ========================================================
//                         STATE
// ========================================================
Orientation ori{0,0,0};
Orientation ref{0,0,0};

unsigned long lastTime = 0;
unsigned long lastPrintTime = 0;
constexpr unsigned long PRINT_PERIOD_MS = 200;

// ========================================================
//                         UTILS
// ========================================================
float wrapAngle(float a) {
  while (a > 180.0f)  a -= 360.0f;
  while (a < -180.0f) a += 360.0f;
  return a;
}

uint8_t encodeAxis(float angle, float th) {
  if (angle >  th) return 0b01;
  if (angle < -th) return 0b10;
  return 0b00;
}

// ========================================================
//                       IMU LOGIC
// ========================================================
void readIMU(Vec3 &acc, Vec3 &gyr, Vec3 &mag) {
  imu.getAGMT();

  acc = {
    imu.accX() * ACC_MG_TO_G,
    imu.accY() * ACC_MG_TO_G,
    imu.accZ() * ACC_MG_TO_G
  };

  gyr = {
    imu.gyrX() - GYRO_BIAS_DPS_X,
    imu.gyrY() - GYRO_BIAS_DPS_Y,
    imu.gyrZ() - GYRO_BIAS_DPS_Z
  };

  mag = {
    (imu.magX() - MAG_OFF_X) * MAG_SCALE_X,
    (imu.magY() - MAG_OFF_Y) * MAG_SCALE_Y,
    (imu.magZ() - MAG_OFF_Z) * MAG_SCALE_Z
  };
}

Orientation accelOrientation(const Vec3 &a) {
  return {
    atan2(a.y, a.z) * RAD_TO_DEG,
    atan2(-a.x, sqrt(a.y*a.y + a.z*a.z)) * RAD_TO_DEG,
    0.0f
  };
}

float magYaw(const Vec3 &m, float roll, float pitch) {
  float r = roll  * DEG_TO_RAD;
  float p = pitch * DEG_TO_RAD;
  float mx = m.x * cos(p) + m.z * sin(p);
  float my = m.x * sin(r)*sin(p) + m.y*cos(r) - m.z*sin(r)*cos(p);
  return wrapAngle(atan2(-my, mx) * RAD_TO_DEG);
}

void updateOrientation(float dt) {
  Vec3 acc, gyr, mag;
  readIMU(acc, gyr, mag);

  Orientation accOri = accelOrientation(acc);

  ori.roll  += gyr.x * dt;
  ori.pitch += gyr.y * dt;
  ori.yaw   += gyr.z * dt;

  float yawMag = magYaw(mag, ori.roll, ori.pitch);

  ori.roll  = wrapAngle(ALPHA_RP  * ori.roll  + (1 - ALPHA_RP)  * accOri.roll);
  ori.pitch = wrapAngle(ALPHA_RP  * ori.pitch + (1 - ALPHA_RP)  * accOri.pitch);
  ori.yaw   = wrapAngle(ALPHA_YAW * ori.yaw   + (1 - ALPHA_YAW) * yawMag);
}

Orientation relativeOrientation() {
  return {
    wrapAngle(ori.roll  - ref.roll),
    wrapAngle(ori.pitch - ref.pitch),
    0.0f
  };
}

// ========================================================
//                       FLEX
// ========================================================
uint8_t readFlexBits() {
  uint8_t bits = 0;

  for (int i = 0; i < NUM_FLEX; i++) {
    long sum = 0;
    for (int k = 0; k < 10; k++) sum += analogRead(flexPins[i]);

    float adc = max(1.0f, sum / 10.0f);
    float v = adc * (V_IN / 4095.0f);
    flexR[i] = R_FIXED[i] * (v / (V_IN - v));

    if (flexR[i] > R_THRESH[i]) bits |= (1 << i);
  }
  return bits;
}

// ========================================================
//               PACKET + SERIAL PRINT
// ========================================================
uint8_t buildPacketAndPrint() {
  Orientation rel = relativeOrientation();

  uint8_t rollBits  = encodeAxis(rel.roll,  ROLL_TH);
  uint8_t pitchBits = encodeAxis(rel.pitch, PITCH_TH);
  uint8_t flexBits  = readFlexBits();

  uint8_t packet =
      (flexBits << 4) |
      (rollBits << 2) |
      (pitchBits);

  Serial.println("---- MEASUREMENTS ----");
  Serial.print("Roll (deg):  ");  Serial.println(rel.roll, 3);
  Serial.print("Pitch (deg): "); Serial.println(rel.pitch, 3);

  Serial.print("Flex R [ohm]: ");
  for (int i = 0; i < NUM_FLEX; i++) {
    Serial.print(flexR[i], 1);
    Serial.print("  ");
  }
  Serial.println();

  Serial.print("PACKET BYTE: 0b");
  Serial.println(packet, BIN);
  Serial.println();

  return packet;
}

// ========================================================
//                   UDP SEND
// ========================================================
void sendPacketUDP(uint8_t data) {
  uint8_t buf[3] = { START_BYTE, data, END_BYTE };

  udp.beginPacket(computerIP, udpPort);
  udp.write(buf, sizeof(buf));
  udp.endPacket();
}

// ========================================================
//                         SETUP
// ========================================================
void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println("\n--- System starting ---");

  Wire.begin();
  Wire.setClock(400000);

  imu.begin(Wire, AD0_VAL);
  if (imu.status != ICM_20948_Stat_Ok) {
    Serial.println("IMU init failed");
    while (1);
  }

  Vec3 acc, gyr, mag;
  readIMU(acc, gyr, mag);
  ori = accelOrientation(acc);
  ori.yaw = magYaw(mag, ori.roll, ori.pitch);
  ref = ori;

  WiFi.begin(ssid, password);
  Serial.print("Connecting WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");

  udp.begin(udpPort);

  lastTime = micros();
  Serial.println("System ready");
}

// ========================================================
//                           LOOP
// ========================================================
void loop() {
  unsigned long now = micros();
  float dt = (now - lastTime) * 1e-6f;
  lastTime = now;
  if (dt <= 0.0f || dt > MAX_DT) return;

  updateOrientation(dt);

  unsigned long nowMs = millis();
  if (nowMs - lastPrintTime >= PRINT_PERIOD_MS) {
    lastPrintTime = nowMs;

    uint8_t packet = buildPacketAndPrint();
    sendPacketUDP(packet);
  }

  delay(5);
}
