#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os

os.environ['PIGPIO_ADDR'] = 'localhost'

import time
import socket
import pigpio
import RPi.GPIO as GPIO
from typing import Optional
from gpiozero import PWMOutputDevice, Servo
from gpiozero.pins.pigpio import PiGPIOFactory

import math
import pickle

import cv2
import numpy as np
from ultralytics import YOLO

# ============================================================
# CONFIGURATION
# ============================================================
MODE = "GLOVE"
UDP_LISTEN_IP = "0.0.0.0"
UDP_PORT = 4210
FRAME_START = 0xAA
FRAME_END = 0x55

CONTROL_PERIOD_SEC = 0.01
SILENCE_STOP_SEC = 0.7

# --- הגדרות LED (PNP BC327) ---
RED_LED_PIN = 26  # אדומים - מכשול (אולטרסוני) + חיווי כשל
GREEN_LED_PIN = 16  # ירוקים - זיהוי חפץ (עיבוד תמונה)
# ------------------------------

factory = PiGPIOFactory()

# ---- Stereo / YOLO config ----
CALIBRATION_FILE_PATH = r"Autonomy/stereo_calibration.pkl"
LEFT_CAM = "/dev/v4l/by-path/platform-fd500000.pcie-pci-0000:01:00.0-usb-0:1.4:1.0-video-index0"
RIGHT_CAM = "/dev/v4l/by-path/platform-fd500000.pcie-pci-0000:01:00.0-usb-0:1.3:1.0-video-index0"

W = 640
H = 480
CAM_FPS = 15
DEFAULT_IMG_SIZE = (W, H)

BOTTLE_CLASS_ID = 39
YOLO_CONF = 0.50
MATCH_Y_TOL = 10

# ---- Stepper config ----
STEPPER_CHUNK = 4
STEPPER_STEP_DELAY_SEC = 0.0015
STEPPER_TICK_SEC = 0.05
_last_stepper_cmd_t = 0.0
STEP_CMD_STALE_SEC = 0.12
_stepper_dir = 0
_last_pkt_t = 0.0
sock = None
last_rx = 0.0

# ============================================================
# GLOBAL STATE
# ============================================================
prev_f0 = prev_f1 = prev_f2 = prev_f3 = 0
_prev_drive_req = "STOP"
_prev_prev_drive_req = "STOP"
_ignore_ultra_active = False
_ignore_ultra_cmd = None

# טיימר עבור חיווי האדום במקרה של כשל בזיהוי
_red_led_fail_until = 0.0

# ============================================================
# ULTRASONIC SENSORS & GPIO SETUP
# ============================================================
US1_TRIG, US1_ECHO = 5, 6
US2_TRIG, US2_ECHO = 13, 19

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

GPIO.setup(US1_TRIG, GPIO.OUT)
GPIO.setup(US1_ECHO, GPIO.IN)
GPIO.setup(US2_TRIG, GPIO.OUT)
GPIO.setup(US2_ECHO, GPIO.IN)

# אתחול לדים (PNP: HIGH = OFF)
GPIO.setup(RED_LED_PIN, GPIO.OUT, initial=GPIO.HIGH)
GPIO.setup(GREEN_LED_PIN, GPIO.OUT, initial=GPIO.HIGH)

GPIO.output(US1_TRIG, GPIO.LOW)
GPIO.output(US2_TRIG, GPIO.LOW)

ULTRA_STOP_CM = 40.0
US_TIMEOUT_SEC = 0.03
ULTRA_MEASURE_PERIOD_SEC = 0.10

_last_ultra_t = 0.0
_last_distances = [None, None]


def _measure_distance_cm(trig, echo) -> Optional[float]:
    GPIO.output(trig, True)
    time.sleep(0.00001)
    GPIO.output(trig, False)
    t0 = time.time()
    while GPIO.input(echo) == 0:
        if time.time() - t0 > US_TIMEOUT_SEC: return None
    ps = time.time()
    while GPIO.input(echo) == 1:
        if time.time() - ps > US_TIMEOUT_SEC: return None
    pe = time.time()
    return (pe - ps) * 17150.0


def ultrasonic_tick():
    global _last_ultra_t, _last_distances
    now = time.time()
    if now - _last_ultra_t >= ULTRA_MEASURE_PERIOD_SEC:
        _last_ultra_t = now
        _last_distances = [
            _measure_distance_cm(US1_TRIG, US1_ECHO),
            _measure_distance_cm(US2_TRIG, US2_ECHO),
        ]


def obstacle_too_close() -> bool:
    for d in _last_distances:
        if d is not None and d < ULTRA_STOP_CM:
            return True
    return False


# ============================================================
# SERVO & MOTORS
# ============================================================
SERVO_PIN = 12
servo = Servo(
    SERVO_PIN,
    initial_value=None,
    min_pulse_width=0.5 / 1000,
    max_pulse_width=2.5 / 1000,
    pin_factory=factory
)

MOVE_STEP = 0.39
current_pos = 0.0
servo_is_open = True


def servo_move_step(direction):
    global current_pos, servo_is_open
    want_close = (direction == 1)
    if want_close and (not servo_is_open): return
    if (not want_close) and servo_is_open: return

    if want_close:
        new_val = current_pos + MOVE_STEP
    else:
        new_val = current_pos - MOVE_STEP

    new_val = max(-1.0, min(1.0, new_val))
    current_pos = new_val
    servo.value = current_pos
    servo_is_open = (not want_close)


RIGHT_RPWM = PWMOutputDevice(2, frequency=1000, initial_value=0, pin_factory=factory)
RIGHT_LPWM = PWMOutputDevice(3, frequency=1000, initial_value=0, pin_factory=factory)
LEFT_RPWM = PWMOutputDevice(20, frequency=1000, initial_value=0, pin_factory=factory)
LEFT_LPWM = PWMOutputDevice(21, frequency=1000, initial_value=0, pin_factory=factory)


def stop_drive():
    RIGHT_RPWM.value = RIGHT_LPWM.value = LEFT_RPWM.value = LEFT_LPWM.value = 0.0


def drive_forward(speed: float = 0.5):
    RIGHT_RPWM.value, LEFT_RPWM.value = speed + 0.01, speed
    RIGHT_LPWM.value, LEFT_LPWM.value = 0.0, 0.0


def drive_reverse():
    RIGHT_LPWM.value, LEFT_LPWM.value = 0.51, 0.50
    RIGHT_RPWM.value, LEFT_RPWM.value = 0.0, 0.0


def turn_right(speed: float = 0.5):
    RIGHT_LPWM.value, LEFT_RPWM.value = speed + 0.01, speed
    RIGHT_RPWM.value, LEFT_LPWM.value = 0.0, 0.0


def turn_left(speed: float = 0.5):
    RIGHT_RPWM.value, LEFT_LPWM.value = speed + 0.01, speed
    RIGHT_LPWM.value, LEFT_LPWM.value = 0.0, 0.0


# ============================================================
# ENCODER & STEPPER
# ============================================================
pi_enc = pigpio.pi()


class YellowJacketEncoder:
    _TRANS = {0b0001: +1, 0b0010: -1, 0b0100: -1, 0b0111: +1, 0b1000: +1, 0b1011: -1, 0b1101: -1, 0b1110: +1}

    def __init__(self, pi, gpio_a, gpio_b):
        self.pi, self.gpio_a, self.gpio_b = pi, gpio_a, gpio_b
        self.ppr_output = 384.5 * (100 / 106)
        self.counts_per_rev_output = self.ppr_output
        self.counts = 0
        self._last_state = (pi.read(gpio_a) << 1) | pi.read(gpio_b)
        self.pi.set_mode(gpio_a, pigpio.INPUT)
        self.pi.set_pull_up_down(gpio_a, pigpio.PUD_UP)
        self.pi.set_mode(gpio_b, pigpio.INPUT)
        self.pi.set_pull_up_down(gpio_b, pigpio.PUD_UP)
        self._cba = pi.callback(gpio_a, pigpio.EITHER_EDGE, self._cb)
        self._cbb = pi.callback(gpio_b, pigpio.EITHER_EDGE, self._cb)
        self._t_last, self._c_last, self._output_rpm = time.time(), 0, 0.0

    def _cb(self, gpio, level, tick):
        new_state = (self.pi.read(self.gpio_a) << 1) | self.pi.read(self.gpio_b)
        self.counts += self._TRANS.get((self._last_state << 2) | new_state, 0)
        self._last_state = new_state

    def update(self, window_s=0.2):
        dt = time.time() - self._t_last
        if dt < window_s: return
        self._output_rpm = 60.0 * ((self.counts - self._c_last) / self.counts_per_rev_output) / dt
        self._t_last, self._c_last = time.time(), self.counts

    def output_revolutions(self): return self.counts / self.counts_per_rev_output

    def zero(self): self.counts = self._c_last = 0


enc = YellowJacketEncoder(pi_enc, 24, 25)


class StepperMotor:
    def __init__(self, pins):
        self.pins, self.pi = pins, pigpio.pi()
        self.seq = [[1, 0, 1, 0], [0, 1, 1, 0], [0, 1, 0, 1], [0, 0, 1, 1]]
        for p in self.pins: self.pi.set_mode(p, pigpio.OUTPUT)

    def step_chunk(self, steps, direction=1, delay_sec=0.002):
        direction = 1 if direction >= 0 else -1
        for _ in range(int(steps)):
            for step in range(4):
                idx = step if direction == 1 else 3 - step
                for i, p in enumerate(self.pins): self.pi.write(p, self.seq[idx][i])
                time.sleep(delay_sec)
        self.deenergize()

    def deenergize(self):
        for p in self.pins: self.pi.write(p, 0)

    def close(self):
        self.deenergize(); self.pi.stop()


_stepper = StepperMotor([23, 22, 27, 17])


def stepper_tick(direction: int):
    global _last_stepper_cmd_t
    if time.time() - _last_stepper_cmd_t >= STEPPER_TICK_SEC:
        _last_stepper_cmd_t = time.time()
        _stepper.step_chunk(STEPPER_CHUNK, direction=direction, delay_sec=STEPPER_STEP_DELAY_SEC)


# ============================================================
# VISION
# ============================================================
_vision_ready = False
_model = _cap_l = _cap_r = _maps_l = _maps_r = _Q = None


def init_vision():
    global _vision_ready, _model, _cap_l, _cap_r, _maps_l, _maps_r, _Q
    if _vision_ready: return
    _model = YOLO('Autonomy/yolov8n_ncnn_model', task='detect')
    _cap_l = cv2.VideoCapture(LEFT_CAM, cv2.CAP_V4L2)
    _cap_r = cv2.VideoCapture(RIGHT_CAM, cv2.CAP_V4L2)
    with open(CALIBRATION_FILE_PATH, 'rb') as f: data = pickle.load(f)
    _Q = data['Q']
    R1, R2, P1, P2, _, _, _ = cv2.stereoRectify(data['cameraMatrix1'], data['distCoeffs1'], data['cameraMatrix2'],
                                                data['distCoeffs2'], (W, H), data['R'], data['T'], alpha=-1)
    _maps_l = cv2.initUndistortRectifyMap(data['cameraMatrix1'], data['distCoeffs1'], R1, P1, (W, H), cv2.CV_32FC1)
    _maps_r = cv2.initUndistortRectifyMap(data['cameraMatrix2'], data['distCoeffs2'], R2, P2, (W, H), cv2.CV_32FC1)
    _vision_ready = True


def detect_bottle_once():
    global _model, _cap_l, _cap_r, _maps_l, _maps_r
    for _ in range(5): _cap_l.grab(); _cap_r.grab()
    _, fl = _cap_l.retrieve();
    _, fr = _cap_r.retrieve()
    f_rect = cv2.remap(fl, _maps_l[0], _maps_l[1], cv2.INTER_LINEAR)
    res = _model.predict(f_rect, conf=YOLO_CONF, classes=[BOTTLE_CLASS_ID], verbose=False)
    X = Z = None
    if res and len(res[0].boxes) > 0:
        X, Y, Z = 0, 0, 100  # Placeholder לערכי עומק אמיתיים
    return {"found": X is not None, "X": X, "Z": Z}


# ============================================================
# MOTION & AUTONOMY
# ============================================================
def drive_distance(d_cm, forward: bool):
    enc.zero();
    enc.update()
    if forward:
        drive_forward()
    else:
        drive_reverse()
    while abs(enc.output_revolutions()) * (math.pi * 7.2) < (d_cm - 1):
        time.sleep(0.01);
        enc.update()
    stop_drive()


def turn_angle(theta_rad, left_turn: bool):
    enc.zero();
    enc.update()
    seg = (39.0 / 2.0) * abs(theta_rad - math.radians(5))
    if left_turn:
        turn_left(0.4)
    else:
        turn_right(0.4)
    while abs(enc.output_revolutions()) * (math.pi * 7.2) < seg:
        time.sleep(0.01);
        enc.update()
    stop_drive()


def bring_bottle_xz():
    global _red_led_fail_until
    print("[AUTO] Starting detection loop...")

    # וידוא צבת פתוחה לפני תחילת התנועה
    servo_move_step(0)
    time.sleep(1)

    start_time = time.time()
    found_bottle = {"found": False}

    # לולאת ניסיונות זיהוי למשך 5 שניות למזעור שגיאות גילוי (BER) [cite: 13, 42]
    while (time.time() - start_time) < 5.0:
        found_bottle = detect_bottle_once()
        if found_bottle["found"]:
            break
        time.sleep(0.1)

    if found_bottle["found"]:
        # הצלחה: הדלקת לדים ירוקים
        GPIO.output(GREEN_LED_PIN, GPIO.LOW)
        time.sleep(1)

        # כיבוי לדים ירוקים רגע לפני תחילת הנסיעה
        GPIO.output(GREEN_LED_PIN, GPIO.HIGH)

        # רצף תנועה ותפיסה
        alpha = math.atan2(found_bottle['X'], 22 + found_bottle['Z'])
        turn_angle(alpha, alpha < 0)
        drive_distance(math.hypot(found_bottle["Z"], found_bottle["X"]), True)

        time.sleep(1)
        servo_move_step(1)  # סגירה
        time.sleep(1)

        # הרמת זרוע 30 מעלות (170 צעדים)
        _stepper.step_chunk(170, direction=1, delay_sec=STEPPER_STEP_DELAY_SEC)
        time.sleep(0.5)

        drive_distance(math.hypot(found_bottle["Z"], found_bottle["X"]), False)

        # הורדת זרוע חזרה
        _stepper.step_chunk(170, direction=-1, delay_sec=STEPPER_STEP_DELAY_SEC)
        time.sleep(0.5)

        servo_move_step(0)  # שחרור
        time.sleep(1)
    else:
        # כשל: הגדרת טיימר ללדים אדומים למשך 5 שניות
        print("[AUTO] Timeout: Bottle not found.")
        _red_led_fail_until = time.time() + 5.0


# ============================================================
# MAIN LOOP
# ============================================================
def run_glove_loop():
    global _stepper_dir, _last_pkt_t, sock, last_rx, _red_led_fail_until
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((UDP_LISTEN_IP, UDP_PORT))
    sock.settimeout(0.02)
    last_rx = _last_pkt_t = time.time()

    while True:
        ultrasonic_tick()

        now = time.time()
        too_close = obstacle_too_close()
        # חיווי אדום אם יש מכשול או אם יש כשל זיהוי בטיימר
        fail_active = (now < _red_led_fail_until)

        if too_close or fail_active:
            GPIO.output(RED_LED_PIN, GPIO.LOW)  # דולק (PNP)
        else:
            GPIO.output(RED_LED_PIN, GPIO.HIGH)  # כבוי

        if now - _last_pkt_t > STEP_CMD_STALE_SEC:
            if _stepper_dir != 0: _stepper_dir = 0; _stepper.deenergize()

        if _stepper_dir != 0: stepper_tick(_stepper_dir)

        try:
            data, _ = sock.recvfrom(1024)
            if len(data) >= 3 and data[0] == FRAME_START and data[2] == FRAME_END:
                handle_payload(data[1])
                last_rx = time.time()
        except socket.timeout:
            if time.time() - last_rx > SILENCE_STOP_SEC: stop_drive()

        time.sleep(CONTROL_PERIOD_SEC)


def handle_payload(payload: int):
    global prev_f0, prev_f1, prev_f2, prev_f3, _stepper_dir, _last_pkt_t
    global _prev_drive_req, _prev_prev_drive_req, _ignore_ultra_active, _ignore_ultra_cmd
    _last_pkt_t = time.time()
    flex = (payload >> 4) & 0x0F
    f0, f1, f2, f3 = (flex >> 0) & 1, (flex >> 1) & 1, (flex >> 2) & 1, (flex >> 3) & 1

    if (f0 == 1 and f1 == 1 and f2 == 1 and f3 == 1) and not (prev_f0 == 1):
        bring_bottle_xz()

    if f3 == 1 and prev_f3 == 0: servo_move_step(1)
    if f2 == 1 and prev_f2 == 0: servo_move_step(0)

    if f0 == 1 and f1 == 0:
        _stepper_dir = -1
    elif f1 == 1 and f0 == 0:
        _stepper_dir = +1
    else:
        _stepper_dir = 0

    pitch_code = payload & 0x03
    roll_code = (payload >> 2) & 0x03
    if pitch_code == 0b01:
        drive_req = "REV"
    elif pitch_code == 0b10:
        drive_req = "FWD"
    elif roll_code == 0b01:
        drive_req = "LEFT"
    elif roll_code == 0b10:
        drive_req = "RIGHT"
    else:
        drive_req = "STOP"

    too_close = obstacle_too_close()

    if drive_req == "REV":
        drive_reverse()
    elif drive_req in ("FWD", "LEFT", "RIGHT"):
        if not too_close:
            if drive_req == "FWD":
                drive_forward()
            elif drive_req == "LEFT":
                turn_left()
            else:
                turn_right()
        else:
            stop_drive()
    else:
        stop_drive()

    prev_f0, prev_f1, prev_f2, prev_f3 = f0, f1, f2, f3
    _prev_prev_drive_req, _prev_drive_req = _prev_drive_req, drive_req


if __name__ == "__main__":
    try:
        init_vision();
        run_glove_loop()
    except KeyboardInterrupt:
        pass
    finally:
        stop_drive()
        GPIO.output(RED_LED_PIN, GPIO.HIGH);
        GPIO.output(GREEN_LED_PIN, GPIO.HIGH)
        GPIO.cleanup();
        print("\n[OFF] System Stopped.")
